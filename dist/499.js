/*! For license information please see 499.js.LICENSE.txt */
(globalThis.webpackChunk_openmrs_esm_form_engine_lib=globalThis.webpackChunk_openmrs_esm_form_engine_lib||[]).push([[499],{6942:(e,n)=>{var t;!function(){"use strict";var r={}.hasOwnProperty;function i(){for(var e="",n=0;n<arguments.length;n++){var t=arguments[n];t&&(e=a(e,s(t)))}return e}function s(e){if("string"==typeof e||"number"==typeof e)return e;if("object"!=typeof e)return"";if(Array.isArray(e))return i.apply(null,e);if(e.toString!==Object.prototype.toString&&!e.toString.toString().includes("[native code]"))return e.toString();var n="";for(var t in e)r.call(e,t)&&e[t]&&(n=a(n,t));return n}function a(e,n){return n?e?e+" "+n:e+n:e}e.exports?(i.default=i,e.exports=i):void 0===(t=function(){return i}.apply(n,[]))||(e.exports=t)}()},9324:(e,n,t)=>{"use strict";t.d(n,{Ay:()=>o,iX:()=>s.useSWRConfig});var r=t(6072),i=t(9888),s=t(8465);const a=r.use||(e=>{if("pending"===e.status)throw e;if("fulfilled"===e.status)return e.value;throw"rejected"===e.status?e.reason:(e.status="pending",e.then((n=>{e.status="fulfilled",e.value=n}),(n=>{e.status="rejected",e.reason=n})),e)}),u={dedupe:!0},o=(s.OBJECT.defineProperty(s.SWRConfig,"defaultValue",{value:s.defaultConfig}),(0,s.withArgs)(((e,n,t)=>{const{cache:o,compare:d,suspense:c,fallbackData:l,revalidateOnMount:f,revalidateIfStale:g,refreshInterval:E,refreshWhenHidden:p,refreshWhenOffline:v,keepPreviousData:R}=t,[h,U,_,b]=s.SWRGlobalState.get(o),[S,T]=(0,s.serialize)(e),m=(0,r.useRef)(!1),V=(0,r.useRef)(!1),y=(0,r.useRef)(S),C=(0,r.useRef)(n),L=(0,r.useRef)(t),O=()=>L.current,I=()=>O().isVisible()&&O().isOnline(),[k,A,w,D]=(0,s.createCacheHelper)(o,S),N=(0,r.useRef)({}).current,F=(0,s.isUndefined)(l)?t.fallback[S]:l,P=(e,n)=>{for(const t in N){const r=t;if("data"===r){if(!d(e[r],n[r])){if(!(0,s.isUndefined)(e[r]))return!1;if(!d(z,n[r]))return!1}}else if(n[r]!==e[r])return!1}return!0},j=(0,r.useMemo)((()=>{const e=!!S&&!!n&&((0,s.isUndefined)(f)?!O().isPaused()&&!c&&(!!(0,s.isUndefined)(g)||g):f),t=n=>{const t=(0,s.mergeObjects)(n);return delete t._k,e?{isValidating:!0,isLoading:!0,...t}:t},r=k(),i=D(),a=t(r),u=r===i?a:t(i);let o=a;return[()=>{const e=t(k());return P(e,o)?(o.data=e.data,o.isLoading=e.isLoading,o.isValidating=e.isValidating,o.error=e.error,o):(o=e,e)},()=>u]}),[o,S]),W=(0,i.useSyncExternalStore)((0,r.useCallback)((e=>w(S,((n,t)=>{P(t,n)||e()}))),[o,S]),j[0],j[1]),x=!m.current,M=h[S]&&h[S].length>0,G=W.data,H=(0,s.isUndefined)(G)?F:G,Y=W.error,q=(0,r.useRef)(H),z=R?(0,s.isUndefined)(G)?q.current:G:H,B=!(M&&!(0,s.isUndefined)(Y))&&(x&&!(0,s.isUndefined)(f)?f:!O().isPaused()&&(c?!(0,s.isUndefined)(H)&&g:(0,s.isUndefined)(H)||g)),J=!!(S&&n&&x&&B),X=(0,s.isUndefined)(W.isValidating)?J:W.isValidating,K=(0,s.isUndefined)(W.isLoading)?J:W.isLoading,Q=(0,r.useCallback)((async e=>{const n=C.current;if(!S||!n||V.current||O().isPaused())return!1;let r,i,a=!0;const u=e||{},o=!_[S]||!u.dedupe,c=()=>s.IS_REACT_LEGACY?!V.current&&S===y.current&&m.current:S===y.current,l={isValidating:!1,isLoading:!1},f=()=>{A(l)},g=()=>{const e=_[S];e&&e[1]===i&&delete _[S]},E={isValidating:!0};(0,s.isUndefined)(k().data)&&(E.isLoading=!0);try{if(o&&(A(E),t.loadingTimeout&&(0,s.isUndefined)(k().data)&&setTimeout((()=>{a&&c()&&O().onLoadingSlow(S,t)}),t.loadingTimeout),_[S]=[n(T),(0,s.getTimestamp)()]),[r,i]=_[S],r=await r,o&&setTimeout(g,t.dedupingInterval),!_[S]||_[S][1]!==i)return o&&c()&&O().onDiscarded(S),!1;l.error=s.UNDEFINED;const e=U[S];if(!(0,s.isUndefined)(e)&&(i<=e[0]||i<=e[1]||0===e[1]))return f(),o&&c()&&O().onDiscarded(S),!1;const u=k().data;l.data=d(u,r)?u:r,o&&c()&&O().onSuccess(r,S,t)}catch(e){g();const n=O(),{shouldRetryOnError:t}=n;n.isPaused()||(l.error=e,o&&c()&&(n.onError(e,S,n),(!0===t||(0,s.isFunction)(t)&&t(e))&&(O().revalidateOnFocus&&O().revalidateOnReconnect&&!I()||n.onErrorRetry(e,S,n,(e=>{const n=h[S];n&&n[0]&&n[0](s.revalidateEvents.ERROR_REVALIDATE_EVENT,e)}),{retryCount:(u.retryCount||0)+1,dedupe:!0}))))}return a=!1,f(),!0}),[S,o]),Z=(0,r.useCallback)(((...e)=>(0,s.internalMutate)(o,y.current,...e)),[]);if((0,s.useIsomorphicLayoutEffect)((()=>{C.current=n,L.current=t,(0,s.isUndefined)(G)||(q.current=G)})),(0,s.useIsomorphicLayoutEffect)((()=>{if(!S)return;const e=Q.bind(s.UNDEFINED,u);let n=0;const t=(0,s.subscribeCallback)(S,h,((t,r={})=>{if(t==s.revalidateEvents.FOCUS_EVENT){const t=Date.now();O().revalidateOnFocus&&t>n&&I()&&(n=t+O().focusThrottleInterval,e())}else if(t==s.revalidateEvents.RECONNECT_EVENT)O().revalidateOnReconnect&&I()&&e();else{if(t==s.revalidateEvents.MUTATE_EVENT)return Q();if(t==s.revalidateEvents.ERROR_REVALIDATE_EVENT)return Q(r)}}));return V.current=!1,y.current=S,m.current=!0,A({_k:T}),B&&((0,s.isUndefined)(H)||s.IS_SERVER?e():(0,s.rAF)(e)),()=>{V.current=!0,t()}}),[S]),(0,s.useIsomorphicLayoutEffect)((()=>{let e;function n(){const n=(0,s.isFunction)(E)?E(k().data):E;n&&-1!==e&&(e=setTimeout(t,n))}function t(){k().error||!p&&!O().isVisible()||!v&&!O().isOnline()?n():Q(u).then(n)}return n(),()=>{e&&(clearTimeout(e),e=-1)}}),[E,p,v,S]),(0,r.useDebugValue)(z),c&&(0,s.isUndefined)(H)&&S){if(!s.IS_REACT_LEGACY&&s.IS_SERVER)throw new Error("Fallback data is required when using suspense in SSR.");C.current=n,L.current=t,V.current=!1;const e=b[S];if(!(0,s.isUndefined)(e)){const n=Z(e);a(n)}if(!(0,s.isUndefined)(Y))throw Y;{const e=Q(u);(0,s.isUndefined)(z)||(e.status="fulfilled",e.value=!0),a(e)}}return{mutate:Z,get data(){return N.data=!0,z},get error(){return N.error=!0,Y},get isValidating(){return N.isValidating=!0,X},get isLoading(){return N.isLoading=!0,K}}})))}}]);